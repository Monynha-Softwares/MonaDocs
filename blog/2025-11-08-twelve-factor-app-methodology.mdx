import AuthorCard from '@site/src/components/AuthorCard';

---
title: "Twelve-Factor App methodology — twelve quick rules for modern apps"
authors: [marcelo-m7]
tags: [architecture, twelve-factor, best-practices]
---

<AuthorCard name="Marcelo Santos" title="Founder & Maintainer" image="/img/marcelo-m7-avatar.svg" linkedin="https://www.linkedin.com/in/marcelo-m7/" github="https://github.com/marcelo-m7" />

The Twelve-Factor App is a methodology for building software-as-a-service apps that are portable, declarative, and suitable for modern cloud platforms. Originally described at https://12factor.net/ and summarized on https://en.wikipedia.org/wiki/Twelve-Factor_App_methodology, the twelve factors provide pragmatic guidance that applies to web apps, microservices, and even static/documentation sites that have runtime components.

<!-- truncate -->

This post highlights each factor and gives short notes on how it applies to documentation sites like MonaDocs and to small-to-medium engineering teams.

1. Codebase

   - One codebase tracked in revision control, many deploys.
   - MonaDocs follows this: the docs, site code, and components live in a single repository. Keep a clear branching strategy (we use `dev`/feature branches and `gh-pages` for deployment) and avoid mixing unrelated projects in the repo.

2. Dependencies

   - Declare and isolate dependencies.
   - Use `package.json` + lockfile (yarn) and avoid relying on global packages during build. Our Docusaurus site expects dependencies installed via `yarn`.

      Example (enforce node version in package.json):

      ```json
      {
         "engines": { "node": ">=20" }
      }
      ```

3. Config

   - Store config in the environment (env vars), not in code.
   - Examples: `USE_SSH` is used at deploy time. Keep secrets (tokens) out of the repo and use CI or environment injection when needed.

4. Backing services

   - Treat backing services (databases, caches, external APIs) as attached resources.
   - MonaDocs is mostly static, but client-side features (e.g., GitHub API calls in the `Repositories` component) must handle rate limits and be resilient when services are unavailable.

      Example: guard fetches and use local cache with TTL:

      ```js
      // simple in-browser cache pattern
      const key = 'mona_repos_cache_v1';
      const cached = JSON.parse(localStorage.getItem(key) || 'null');
      if (cached && Date.now() - cached.ts < 1000 * 60 * 60 * 6) {
         return cached.data;
      }
      // otherwise fetch and persist
      ```

5. Build, release, run

   - Strictly separate build and run stages. `yarn build` produces static assets; `yarn serve` runs them.
   - Avoid embedding runtime-only code that executes during the build (e.g., `window` or `localStorage`) — guard such calls to keep the build portable.

      Example guard used in the repo:

      ```js
      if (typeof window !== 'undefined') {
         const v = localStorage.getItem('portfolio_selected_tech');
      }
      ```

6. Processes

   - Execute the app as one or more stateless processes. For MonaDocs the built site is static files served by any static host; any server-side API should be stateless.

7. Port binding

   - Self-contained services expose ports. Docusaurus dev server exposes a port (3000) during development. For CI and production, the output is static and served by a host.

8. Concurrency

   - Scale out via process model (workers). Not typically necessary for static docs, but useful if adding dynamic build pipelines or preview services.

9. Disposability

   - Fast startup and graceful shutdown. Keep build/serve scripts simple so they can be used in CI and local dev.

... (rest omitted for brevity - content kept the same)
